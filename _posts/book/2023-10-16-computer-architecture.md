---
title: "혼자 공부하는 컴퓨터구조+운영체제(1)"
date: 2023-10-17 20:25:00 +0900
categories: [Book]
tags: [computer, architecture, os]
---

> `컴퓨터 구조`와 `운영체제`의 기본적인 용어와 개념을 정리하고, 기억해야할 것들을 정리해 본다.



## 컴퓨터 구조

`컴퓨터 구조` `데이터` `명령어` `CPU` `메모리` `보조기억장치` `입출력장치`

**1. 컴퓨터 구조**

- 컴퓨터 구조를 이해함으로써 문제 해결능력 향상 가능.
- 컴퓨터 구조를 이해하면 `성능/용량/비용`을 고려하여 개발할 수 있다.

- 컴퓨터구조는 크게 컴퓨터가 이해하는 정보(데이터, 명령어),  
컴퓨터의 네 가지 핵심부품(CPU, 메모리, 보조기억장치, 입출력장치)으로 나뉜다.

  `데이터` : 컴퓨터가 이해하는 숫자, 문자, 이미지와 같은 정적인 정보  
  `명령어` : 데이터를 움직이고 컴퓨터를 작동시키는 정보  

  `CPU` : 메모리에 저장된 명령어를 읽어들이고, 해석하고, 실행하는 부품  
  `메모리` : 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품  
  `보조기억장치` : 전원이 꺼져도 보관할 프로그램을 저장하는 부품  
  `입출력장치` : 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환할 수 있는 부품(마이크, 마우스, 스피커...)  
  `시스템 버스` : 네 가지 핵심 부품들이 서로 정보를 주고받는 통로(주소 버스, 데이터 버스, 제어 버스로 구성)

<br>

**2. 데이터**

- 비트는 0과 1로 표현할 수 있는 가장 작은 정보 단위.
  ```markdown
  1byte=8bit, 1kB=1,000byte, 1MB=1,000kB, 1GB=1,000MB, 1TB=1,000GB
  ```
  {: .nolineno}

- 문자 집합 : 컴퓨터가 인식할 수 잇는 문자의 모음. 문자를 인코딩하여 0과 1로 표현할 수 있다.
- 아스키 코드 : 아스키 문자에 할당된 0~127까지 총 128가지의 수가 대응된 고유의 수
- EUC-KR : 한글을 2바이트 크기로 인코딩할 수 있는 완성형 인코딩 방식
- 유니코드 : 여러 나라 문자들을 광범위하게 사용 가능.(UTF-8, UTF-16,UTF-32)

<br>

**3. 명령어**

- 컴퓨터가 이해하고 실행할 수 있는 언어(`저급 언어=명령어`)  
  기계어 : 0과 1로 이루어진 명령어  
  어셈블리어 : 기계어를 사람이 읽기 편한 형태로 번역한 것

- 사람이 이해하고 작성하기 쉽게 만들어진 언어(`고급 언어`)

- 고급 언어 -> 저급언어로 변환되는 2가지 방식(컴파일 방식, 인터프리트 방식)  
  컴파일 언어 : 컴파일러에 의해 소스 코드 `전체`가 변환되어 실행되는 방식  
  인터프리터 언어 : 인터프리터에 의해 소스 코드가 `한 줄씩` 변환되어 실행되는 방식(`Python` 컴파일 언어에 비해 느림..)

- 명령어는 `연산 코드`와 `오퍼랜드`로 구성  
  연산 코드 : 명령어가 수행할 연산을 의미  
  오퍼랜드 : 연산에 사용할 데이터 또는 그 데이터가 저장된 위치
  
> 스택과 큐(PUSH와 POP명령어를 통해 저장하고 꺼냄)  
스택 : LIFO 방식, 후입선출  
큐 : FIFO 방식, 선입선출
{: .prompt-tip }

- 주소 지정 방식 : 연산에 사용할 데이터 위치를 찾는 방법  
(즉시 주소, 직접 주소, 간접 주소, 레지스터 주소, 레지스터 간접 주소 지정 방식)

<br>

**4-1. CPU**
<br>
![cpu](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbpaeZ3%2FbtrjYhCOTDe%2FM12OchWnFuYRCfDlvnCvqk%2Fimg.png){: width="300px"}  
<!-- 이미지 출처: https://mk28.tistory.com/15{: .right } -->

- `ALU` : 레지스터들로부터 피연산자를 받아들이고, 제어장치로부터 제어 신호를 받아들인다.
- ALU는 연산 결과와 플래그를 내보낸다.

![cpu](https://velog.velcdn.com/images/bebrain/post/1ba0cad4-5081-444a-ab0b-9b69c13fe10c/image.png){: width="600px"}

- `제어장치` : 클럭, 현재 수행할 명령어, 플래그, 제어 신호를 받아들인다.
- 제어장치는 CPU 내부와 외부로 제어 신호를 내보낸다.

> 플래그(flag)의 종류  
부호 플래그, 제로 플래그, 캐리 플래그, 오버플로우 플래그, 인터럽트 플래그, 슈퍼바이저 플래그
{: .prompt-tip }

![cpu](https://velog.velcdn.com/images/bebrain/post/78135fb5-cddb-4957-9c85-03164fe5c320/image.png){: width="600px"}
<center>이미지 출처 : https://velog.io/@vov3616/운영체제-스터디-CPU의-작동원리</center>  
<br>

- 레지스터 종류  
  프로그램 카운터 : 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소 저장  
  명령어 레지스터 : 해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어 저장  
  메모리 주소 레지스터 : 메모리의 주소 저장  
  메모리 버퍼 레지스터 : 메모리와 주고받을 값(데이터와 명령어) 저장  
  플래그 레지스터 : 연산 결과 또는 CPU 상태에 대한 부가적인 정보 저장  
  범용 레지스터 : 데이터와 주소 모두 저장  
  스택 포인터 : 스택 최상단의 위치를 저장  
  베이스 레지스터 : 기준 주소로서의 역할  

- 명령어 사이클 : 하나의 명령어가 처리되는 주기(인출, 실행, 간접, 인터럽트 사이클로 구성)  
- 인터럽트 : CPU의 정상적인 작업을 방해하는 신호(예외, 하드웨어 인터럽트로 구성)
- 인터럽트 서비스 루틴 : 인터럽트를 처리하기 위한 동작들로 이루어진 프로그램

> 인터럽트 - 예외 - 폴트, 트랩, 중단, 소프트웨어 인터럽트
{: .prompt-info }

<details><summary>예외의 종류 좀 더 알아보기</summary>
- 예외가 발생하면 CPU는 하던 일을 중단하고 해당 예외를 처리한다. 예외를 처리하고 나면 CPU는 다시 본래 하던 작업으로 되돌아와 실행을 재개한다.<br>
- 폴트 : 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개<br>
- 트랩 : 예외를 처리한 직후 예외가 발생한 다음 명령어부터 실행을 재개<br>
- 중단 : CPU가 실행 중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발생했을 때<br>
- 소프트웨어 인터럽트 : 시스템 호출이 발생했을 때 
</details> 

<br>

**4-2. CPU 성능 향상 기법**

- 클럭 : 클럭 속도가 높은 CPU는 빠르게 작동한다.

> 클럭 속도는 헤르츠(Hz) 단위로 측정. 1초에 클럭이 몇 번 반복되는지를 의미  
클럭 속도는 일정하지 않고 기본 클럭 속도(Base), 최대 클럭 속도(Max)로 나뉜다.  
최대 클럭 속도를 강제로 더 끌어 올리는 것을 오버클러킹(Overclocking)이라고 한다.
{: .prompt-tip }

- `코어` : CPU 내에서 명령어를 실행하는 부품
- `멀티코어` : 여러 개의 코어를 포함하는 CPU
- `스레드` : 하드웨어적 스레드와 소프트웨어적 스레드로 나뉨
- `멀티스레드` : 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU

- 명령어 병렬 처리 기법  
  `명령어 파이프라이닝` : 동시에 여러 개의 명령어를 겹쳐 실행하는 기법  
  `슈퍼스칼라` : 여러 개의 명령어 파이프라인을 두는 기법  
  `비순차적 명령어 처리 기법` : 파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 기법

> 명령어 파이프 라인 : 명령어 인출 -> 명령어 해석 -> 명령어 실행 -> 결과 저장 순
{: .prompt-tip }
> 파이프라인 위험 : 높은 성능을 가져오는 장점. 특정 상황에서는 성능 향상에 실패하는 경우 발생  
데이터 위험 : 데이터 의존적인 두 명령어를 무작정 동시에 실행하려 할 때  
제어 위험 : 분기 등으로 인한 '프로그램 카운터의 갑작스러운 변화'에 의해 발생  
구조적 위험 : 서로 다른 명령어가 동시에 ALU, 레지스터 등을 사용하려고 할 때 발생
{: .prompt-danger }

- `ISA` : CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속  
- `CISC` : 복잡하고 다양한 종류의 가변 길이 명령어 집합 활용  
- `RISC` : 단순하고 적은 종류의 고정 길이 명령어 집합 활용

<br>

**5. 메모리**

- `RAM`은 `휘발성 저장 장치`  
  DRAM(Dynamic) : 시간이 지나면 저장된 데이터가 점차 `사라지는` RAM  
  SRAM(Static) : 시간이 지나도 저장된 데이터가 `사라지지 않는` RAM  
  SDRAM : 클럭에 맞춰 동작하며 클럭마다 CPU와 정보를 주고받을 수 있는 DRAM  
  DDR SDRAM(Double Data Rate) : SDR SDRAM에 비해 두배 넓은 대역폭(데이터를 주고받는 길의 너비)  

- `물리 주소` : 메모리 하드웨어상의 주소
- `논리 주소` : CPU와 실행 중인 프로그램이 사용하는 주소
- `MMU` : 논리 주소를 무리 주소로 변환하는 역할
- `베이스 레지스터` : 프로그램의 첫 물리 주소를 저장
- `한계 레지스터` : 실행 중인 프로그램의 논리 주소의 최대 크기를 저장

- `저장 장치 계층 구조` : 각기 다른 용량과 성능의 저장 장치들을 계층화한 것

![memory](https://velog.velcdn.com/images%2Fyu-jin-song%2Fpost%2Ff9c8088c-0fec-4dad-ac95-ddf3601aa1d4%2F메모리_계층_구조.png){: width="600" height="300" }

- `캐시 메모리` : CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위한 저장 장치
- `캐시 적중률`이 높으면 CPU의 메모리 접근 횟수를 줄일 수 있다.
- 캐시 메모리는 `참조 지역성의 원리`에 따라 데이터를 예측하여 캐시 적중률을 높인다.

<br>

**6. 보조기억장치**

![memory](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F2466F14557431B7133){: width="600" height="300" }

![memory](https://t1.daumcdn.net/cfile/tistory/99DB3D4D5B3B06FA3A){: width="600" height="300" }

- `하드 디스크` 구성요소 : `플래터`, `스핀들`, `헤드`, `디스크 암`
- 플래터는 `트랙`과 `섹터`로 나뉘고, 여러 플래터의 동일한 트랙이 모여 실린더를 이룸
- 하드 디스크 `데이터 접근 시간` : 탐색 시간, 회전 지연, 전송 시간으로 나뉨
- `플래시 메모리` : SLC(한 셀에 1비트), MLC(한 셀에 2비트), TLC(한 셀에 3비트)
- 플래시 메모리의 읽기와 쓰기는 `페이지 단위`, 삭제는 `블록 단위`로 이루어짐

- `RAID` : 데이터의 안정성 혹은 높은 성능을 위해 여러 하드 디스크나 SSD를 마치 하나의 장치처럼 사용하는 기술
<details><summary>RAID의 종류 좀 더 알아보기</summary>
- RAID 0 : 데이터를 단순히 병렬로 분산하여 저장<br>
- RAID 1 : 완전한 복사본 만듬<br>
- RAID 4 : 패리티를 저장한 장치를 따로 두는 방식<br>
- RAID 5 : 패리티를 분산하여 자장하는 방식<br>
- RAID 6 : 서로 다른 두 개의 패리티를 두는 방식
</details> 

<br>

**7. 입출력장치**

- 입출력장치는 `장치 컨트롤러`를 통해 컴퓨터 내부와 정보를 주고받음
- `장치 드리이버`는 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게 하는 프로그램

- 프로그램 입출력 방식  
  메모리 맵 입출력 : 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 `하나의 주소공간`으로 간주하는 방식  
  고립형 입출력 : 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 `별도로 분리`하는 방식  
  인터럽트 기반 입출력 : 입터럽트로써 입출력을 수행하는 방식  
  DMA 입출력 : CPU를 거치지 않고 메모리와 입출력장치 간의 데이터를 주고받는 방식
  
- `입출력 버스` : 입출력장치와 컴퓨터 내부를 연결 짓는 통로. 입출력 작업 과정에서 시스템 버스 사용 횟수를 줄여줌
