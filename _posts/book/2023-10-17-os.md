---
title: "혼자 공부하는 컴퓨터구조+운영체제(2)"
date: 2023-10-18 13:15:00 +0900
categories: [Book]
tags: [computer, architecture, os]
---

> `컴퓨터 구조`와 `운영체제`의 기본적인 용어와 개념을 정리하고, 기억해야할 것들을 정리해 본다.



## 운영체제

`운영체제` `프로세스와 스레드` `CPU 스케줄링` `프로세스 동기화` `교착상태` `가상메모리` `파일 시스템`

**1. 운영체제**

- `운영체제`는 실행할 프로그램에 필요한 자원을 할당하고, 프로그램이 올바르게 실행되도록 돕는 특별한 프로그램이다.
- 운영체제와의 대화를 통해 하드웨어와 프로그램을 더 깊이 이해하고 `문제 해결`의 실마리를 찾을 수 있다.

![kernel](/assets/img/imges/kernel.jpeg){: width="400px"} 

- 운영체제는 항상 메모리 내 `커널 영역`에 따로 적재되어 실행된다.
- `커널 영역` : 운영체제의 핵심 기능을 담당  
  >커널에 포함되지 X : 사용자 인터페이스(UI)  
  >UI 종류 : 그래픽 유저 인터페이스(GUI), 커맨드 라인 인터페이스(CLI)
- `이중 모드` : CPU가 명령어를 실행하는 모드를 `커널 모드`와 `사용자 모드`로 구분하는 방식

> 사용자 모드 : 운영체제 서비스를 제공받을 수 없는 실행 모드  
커널 모드 : 운영체제 서비스를 제공받을 수 있는 실행 모드(커널 영역의 코드를 실행 할 수 있다.)
{: .prompt-tip }

- `시스템 호출` : 운영체제의 서비스를 제공받기 위해 커널 모드로 전환하는 방법
- 운영체제 서비스의 종류로는 프로세스 관리, 자원 접근 및 할당, 파일 시스템 관리가 있다.
<details><summary>시스템 호출의 종류 좀 더 알아보기</summary>
- 프로세스 관리 : fork(), execve(), exit(), waitpid()<br>
- 파일 관리 : open(), close(), read(), write(), stat()<br>
- 디렉터리 관리 : chdir(), rmdir()<br>
- 파일 시스템 관리 : umount()
</details>

<br>

**2. 프로세스와 스레드**

- `프로세스` : 실행 중인 프로그램. 포그라운드 프로세스와 백그라운드 프로세스로 나뉨  
  >`포그라운드 프로세스` : 사용자가 보는 앞에서 실행되는 프로세스  
  >`백그라운드 프로세스` : 사용자가 보지 못하는 뒤편에서 실행되는 프로세스(Unix->데몬, 윈도우->서비스 라고 불림)
- 운영체제는 `프로세스 제어 블록(PCB)`을 통해 여러 프로세스를 관리함
- 프로세스 간에 실행을 전환하는 것을 `문맥 교환`이라고 한다.

![context](/assets/img/imges/context.jpeg){: width="400px"}

- 프로세스 A -> 프로세스 B로 실행순서가 넘어갈 때, 중간정보를 백업한다.

- `프로세스 사용자 영역`에 크게 코드 영역, 데이터 영역, 스택 영역, 힙 영역으로 나뉘어 배치됨

![code](/assets/img/imges/code.jpeg){: width="500px"}

- `프로세스 상태` : 생성, 준비, 실행, 대기, 종료

![process](/assets/img/imges/process.jpeg){: width="500px"}

- 프로세스가 다른 프로세스를 생성한 경우 `생성한 프로세스 = 부모 프로세스`, `생성된 프로세스 = 자식 프로세스`

- 많은 운영체제는 `프로세스 계층 구조`로 프로세스를 관리

![tree](/assets/img/imges/process_tree.jpeg){: width="500px"}

- `스레드` : 프로세스 내의 실행 흐름 단위

![multi](/assets/img/imges/multi.jpeg){: width="500px"}
<center>이미지 출처 : https://tscofet.oopy.io/0dc22a9c-a968-4a61-9e7a-243ef3904dfa</center>
<br>

- `멀티프로세스` : 여러 프로세스를 동시에 실행하는 것(프로세스끼리 자원 공유 X)
- `멀티스레드` : 여러 스레드로 프로세스를 동시에 실행하는 것(프로세스끼리 자원 공유 O)

> 멀티스레드가 멀티프로세스에 비해 자원을 더 효율적으로 공유하며 사용한다
{: .prompt-tip }

<br>

**3. CPU 스케줄링**

- `CPU 스케줄링`은 공정하고 합리적으로 CPU 자원을 배분하는 방법을 의미
- 프로세스는 `우선순위`를 가지고 있고, 이는 PCB에 명시됨

- 운영체제는 효율적인 스케줄링을 위해 `스케줄링 큐`를 사용

![tree](/assets/img/imges/schedule.jpeg){: width="500px"}

- `준비 큐` : CPU 할당을 기다리는 프로세스들을 위한 큐
- `대기 큐` : 입출력장치를 기다리는 프로세스들을 위한 큐


- `선점형 스케줄링` : 프로세스가 이용 중인 자원을 뺴앗을 수 있다.

![pre](/assets/img/imges/pre.jpeg){: width="500px"}

- `비선점형 스케줄링` : 프로세스가 이용 중인 자원을 뺴앗을 수 없다.

![nonpre](/assets/img/imges/non-pre.jpeg){: width="500px"}

- `선입 선처리 스케줄링` : 준비 큐에 삽입된 순서대로 CPU를 할당(선착순)
- `최단 작업 우선 스케줄링` : 준비 큐에 삽입된 프로세스들 중 CPU 사용 `시간의 길이가 가장 짧은` 프로세스부터 CPU 할당

- `라운드 로빈 스케줄링` : 정해진 시간만큼만 돌아가며 CPU 할당

![round](/assets/img/imges/round.jpeg){: width="500px"}

- `우선순위 스케줄링` : 가장 높은 우선순위를 가진 프로세스에 CPU 할당  
  우선순위가 낮은 프로세스의 실행이 계속 연기되는 `기아 현상` 발생. `에이징 기법`을 통해 기아 현상 방지

![pre](/assets/img/imges/priority1.jpeg){: width="500px"}
![pre](/assets/img/imges/priority2.jpeg){: width="500px"}

- `다단계 피드백 큐 스케줄링` : 프로세스들이 큐 사이를 이동할 수 있는 다단계 큐 스케줄링

<br>

**4. 프로세스 동기화**

![synch](/assets/img/imges/synch.jpeg){: width="500px"}

- `동기화` : 특정 자원에 접근할 때 한 개의 프로세스만 접근하게 하거나 프로세스를 올바른 순서대로 실행하게 하는 것
- `공유자원` : 공동으로 사용하는 자원. 전역 변수, 파일, 입출력장치, 보조기억장치 등이 될 수 있다.
- `임계 구역` : 공유 자원에 접근하는 코드 중 동시에 실행하면 문제가 발생할 수 있는 코드 영역을 의미.  
  임계 구역에 진입한 프로세스가 있다면 다른 프로세스는 임계 구역 밖에서 기다려야 한다.

![critical](/assets/img/imges/critical.jpeg){: width="500px"}

<details><summary>임계 구역 문제 해결법 알아보기(원칙)</summary>
- 상호 배제 : 한 프로세스가 임계 구역에서 작업 중이면 다른 프로세스가 임계 구역에 들어갈 수 없도록 제어하는 것<br>
- 진행 : 임계 구역에 어떤 프로세스도 진입하지 않았다면 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다<br>
- 유한 대기 : 임계 구역에 진입하고자 하는 프로세스는 언젠가는 임계 구역에 들어올 수 있어야 한다
</details>

- `뮤텍스 락` : 임계 구역을 잠금으로써 프로세스 간의 상호 배제를 이룸

![mutex](/assets/img/imges/mutex.jpeg){: width="500px"}

- `세마포` : 공유 자원이 여러 개 있는 임계 구역 문제도 해결할 수 있는 동기화 도구

![semaphore](/assets/img/imges/semaphore.jpeg){: width="500px"}

- `모니터` : 세마포에 비해 사용자가 사용하기 편리한 동기화 도구로 조건 변수를 사용

<br>

**5. 교착 상태**

- `교착 상태` : 일어나지 않을 사건을 기다리며 무한히 대기하는 현상

![dining](/assets/img/imges/dining.jpeg){: width="500px"}

> 식사하는 철학자 문제는 교착 상태의 발생을 보여주는 예시이다.

- `자원 할당 그래프`를 이용해 교착 상태를 표현할 수 있다.

![resource](/assets/img/imges/resource.jpeg){: width="500px"}

> 프로세스가 사용중인 자원 : 자원 -> 프로세스 방향 화살표  
> 프로세스가 기다리는 자원 : 프로세스 -> 자원 방향 화살표

- `교착 상태 발생 조건`은 상호 배제, 점유와 대기, 비선점, 원형 대기이다.

![round-wait](/assets/img/imges/round-wait.jpeg){: width="500px"}  
  >상호 배제 : 한 프로세스가 사용 중인 자원을 다른 프로세스가 사용할 수 없는 상황  
  >점유와 대기 : 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다리는 상황  
  >비선점 : 다른 프로세스의 자원을 강제로 빼앗지 못하고 작업이 끝나길 기다리는 상황  
  >원형 대기 : 서로가 서로의 자원을 기다리며 원의 형태로 자원을 대기하는 상황

- `교착 상태 예방` : 교착 상태의 발생 조건 중 하나를 충족하지 못하게 하는 방법
- `교착 상태 회피` : 안전 상태를 유지할 수 있는 경우에만 자원을 할당하는 방법
- `교착 상태 검출 후 회복` : 교착 상태 발생 여부를 주기적으로 검사하고, 교착 상태가 발생하면 그때그때 회복하는 방식

<br>

**6. 가상 메모리**

- `스와핑` : 메모리에서 사용되지 않는 일부 프로세스를 보조기억장치로 내보내고 실행할 프로세스를 메모리로 들여보내는 메모리 관리 기법

![swaping](/assets/img/imges/swaping.jpeg){: width="500px"}

- `최초 적합` : 최초로 발견한 적재 가능한 빈 공간에 프로세스 배치

![good1](/assets/img/imges/good1.jpeg){: width="500px"}

- `최적 적합` : 프로세스가 적재될 수 있는 가장 작은 공간에 프로세스 배치

![good2](/assets/img/imges/good2.jpeg){: width="500px"}

- `최악 적합` : 프로세스가 적재될 수 있는 가장 큰 공간에 프로세스 배치

![good3](/assets/img/imges/good3.jpeg){: width="500px"}

- `외부 단편화` : 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상  
  >페이징 기법을 통해 해결할 수 있다.

- `페이징` : 물리 주소 공간을 프레임 단위로 자르고, 프로세스의 논리 주소 공간을 페이지 단위로 자른 뒤 각 페이지를 프레임에 할당하는 가상 메모리 관리 기법
  >페이지 : 프로세스의 논리 주소로 공간을 일정한 크기 단위로 자른 것
  >프레임 : 메모리의 물리 주소 공간을 일정한 크기 단위로 자른 것

![paging](/assets/img/imges/paging.jpeg){: width="500px"}

- `페이지 테이블`을 통해 페이지가 적재된 프레임을 찾을 수 있다.
- 페이지 테이블 구성요소 : 페이지 번호, 프레임 번호, 유효 비트, 보호 비트, 접근 비트, 수정 비트 등

![table](/assets/img/imges/page-table.jpeg){: width="500px"}

- `PTBR` : 각 프로세스의 페이지 테이블이 적재된 주소를 가리킴
- `TLB` : 페이지 테이블의 캐시 메모리 역할을 수행하기 위해 페이지 테이블의 일부를 저장

- `요구 페이징` : 페이지가 필요할 때에만 메모리에 적재하는 기법  
  >요구 페이징을 통해 페이지를 적재하다 보면 메모리가 가득차게 되어 스왑 아웃을 해야한다.
- `페이지 교체 알고리즘` : 어떤 페이지를 스왑 아웃 할 것인지를 결정하는 방법
- `페이지 교체 알고리즘`에는 `FIFO`, `최적`, `LRU 페이지 교체 알고리즘`이 있다.

- `FIFO` : 가장 먼저 올라온 페이지부터 교체

![fifo](/assets/img/imges/fifo.jpeg){: width="500px"}

- `최적` : 앞으로 오랫동안 사용하지 않을 페이지를 예측하여 교체(이상적)

![best-page](/assets/img/imges/best-page.jpeg){: width="500px"}

- `LRU 페이지 교체 알고리즘` : 최근에 사용되지 않는 페이지는 앞으로도 사용되지 않을것이라고 예측하는 방식

![LRU](/assets/img/imges/LRU.jpeg){: width="500px"}

- `스래싱` : 지나치게 빈번한 페이지 교체로 인해 CPU 이용률이 낮아지는 문제를 뜻함
- `프레임 할당 방식` 종류 : 균등 할당, 비례 할당, 작업 집합 모델 기반, 페이지 폴트율 기반 프레임 할당 방식

<br>

**7. 파일 시스템**

- `파일` : 의미 있고 관련 있는 정보를 모은 논리적인 단위
- 운영체제는 파일의 `확장자`를 통해 파일의 유형을 파악할 수 있다.
- 파일의 `속성`에는 파일과 관련된 다양한 부가 정보들이 있다.

![file-data](/assets/img/imges/file-data.jpeg){: width="500px"}

- 생성, 삭제, 열기, 닫기, 쓰기 등의 작업을 위해 `시스템 호출`을 사용해야 함
- `디렉터리`를 이용하면 여러 개의 파일 또는 디렉터리를 묶어 관리할 수 있다.

![directory](/assets/img/imges/directory.jpeg){: width="500px"}

- `경로` : 디렉터리를 이용해 위치를 특정 짓는 정보
- `절대 경로`는 루트 디렉터리부터 시작하는 경로이고, `상대 경로`는 현재 디렉터리부터 시작하는 경로이다.

- `파티셔닝` : 하드 디스크나 SSD처럼 용량이 큰 저장 장치를 하나 이상의 논리적인 여러 단위로 구획하는 작업
- `포매팅` : 파일 시스템을 설정하여 어떤 방식으로 파일을 저장하고 관리할 것인지를 결정하고, 새로운 데이터를 쓸 수 있게 하는 작업

![formating](/assets/img/imges/formating.jpeg){: width="500px"}

- `연속 할당` : 보조기억장치 내 연속적인 블록에 파일을 할당하는 방식
- `연결 할당` : 각 블록 일부에 다음 블록의 주소를 저장하여 블록들을 연결 리스트 형태로 관리하는 방식
- `색인 할당` : 파일의 모든 블록 주소를 색인 블록에 모아 관리하는 방식

![file-assignment](/assets/img/imges/file-assignment.jpeg){: width="500px"}

- `FAT 파일 시스템` : FAT를 이용하는 연결 할당 기반의 파일 시스템
- `유닉스 파일 시스템` : i-node를 이용하는 색인 할당 기반의 파일 시스템

